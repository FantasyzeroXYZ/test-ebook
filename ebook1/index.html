<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Epub.js Media Overlay Player - æœ€ç»ˆä¿®å¤ V14 (ç§»é™¤é”™è¯¯çš„ goTo è°ƒç”¨)</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://unpkg.com/epubjs/dist/epub.min.js"></script>
    
    <style>
        body { font-family: sans-serif; margin: 20px; }
        #controls { text-align: center; margin-bottom: 20px; }
        #viewer { width: 80%; height: 500px; margin: 20px auto; border: 1px solid #ccc; }
        .data-box { background: #f4f4f4; padding: 15px; border: 1px dashed #aaa; margin-top: 10px; max-height: 400px; overflow-y: auto; }
        .mo-active { 
            background-color: #ffda6a; 
            padding: 1px 3px; 
            border-radius: 3px;
            box-shadow: 0 0 5px rgba(255, 218, 106, 0.5);
            transition: all 0.3s ease;
        }
        .error { color: red; font-weight: bold; }
        .success { color: green; }
        .warning { color: orange; }
        button { padding: 10px 20px; margin: 0 5px; cursor: pointer; }
        
        #viewer .epub-container {
            line-height: 1.6;
            padding: 20px;
        }
        
        .progress-container {
            width: 80%;
            margin: 10px auto;
            background: #f0f0f0;
            border-radius: 10px;
            height: 8px;
        }
        .progress-bar {
            height: 100%;
            background: #4CAF50;
            border-radius: 10px;
            width: 0%;
            transition: width 0.1s ease;
        }

        .file-input-wrapper {
            margin: 20px 0;
            text-align: center;
        }
    </style>
</head>
<body>

    <h1>ğŸ™ï¸ EPUB3 Media Overlay Player (æœ€ç»ˆä¼˜åŒ–ç‰ˆ V14)</h1>

    <div class="file-input-wrapper">
        <input type="file" id="epub-file" accept=".epub">
        <button id="load-btn">åŠ è½½EPUBæ–‡ä»¶</button>
    </div>

    <div id="controls">
        <button id="play-pause-btn">â–¶ï¸ æ’­æ”¾ / æš‚åœ</button>
        <button id="stop-btn">â¹ï¸ åœæ­¢</button>
        <button id="seek-back-btn">âª å¿«é€€10ç§’</button>
        <button id="seek-forward-btn">â© å¿«è¿›10ç§’</button>
        <p>å½“å‰çŠ¶æ€: <span id="player-status">æœªåŠ è½½</span> | ç‰‡æ®µ: <span id="current-fragment-id">N/A</span></p>
        <div class="progress-container">
            <div class="progress-bar" id="progress-bar"></div>
        </div>
        <p id="time-display">00:00 / 00:00</p>
    </div>

    <div id="viewer"></div>

    <div class="data-box" id="info-output">è¯·é€‰æ‹©å¹¶åŠ è½½EPUBæ–‡ä»¶...</div>

    <script>
        // --- å…¨å±€å˜é‡ ---
        const HIGHLIGHT_CLASS = 'mo-active'; 
        
        let book;
        let rendition;
        let player;

        // --- MediaOverlayPlayerç±» ---
        class MediaOverlayPlayer {
            constructor(book, rendition, infoOutput) {
                this.book = book;
                this.rendition = rendition;
                this.infoOutput = infoOutput;
                this.queue = [];      
                this.currentIndex = -1;
                this.isPlaying = false;
                this.audioElement = new Audio();
                this.activeClass = HIGHLIGHT_CLASS;
                
                this.audioElement.ontimeupdate = this.updateCurrentHighlight.bind(this);
                this.audioElement.onended = () => {
                    this.isPlaying = false;
                    this.updateStatus("âœ… æ’­æ”¾ç»“æŸ");
                };
                
                this.currentAudioFile = null;
                this.audioGroups = new Map();
            }

            // --- æ—¶é—´æ ¼å¼è½¬æ¢ ---
            timeToSeconds(timeStr) {
                if (!timeStr) return 0;
                if (timeStr.endsWith('s')) {
                    return parseFloat(timeStr.slice(0, -1));
                }
                const parts = timeStr.split(':').map(parseFloat);
                if (parts.length === 3) {
                    return parts[0] * 3600 + parts[1] * 60 + parts[2];
                }
                return parseFloat(timeStr); 
            }

            // --- æ ¸å¿ƒåˆå§‹åŒ– ---
            async initialize() {
                this.updateStatus("æ­£åœ¨è§£æ EPUB ç»“æ„...");
                
                try {
                    await this.book.ready;
                    
                    const [metadata, manifest, spine, navigation] = await Promise.all([
                        this.book.loaded.metadata,
                        this.book.loaded.manifest,
                        this.book.loaded.spine,
                        this.book.loaded.navigation
                    ]);
                    
                    this.activeClass = metadata.media_active_class || HIGHLIGHT_CLASS;
                    this.updateInfo('<span class="success">âœ… å…ƒæ•°æ®åŠ è½½æˆåŠŸ</span>');
                    this.updateInfo('- ä¹¦å: ' + (metadata.title || 'æœªçŸ¥'));
                    this.updateInfo('- ä½œè€…: ' + (metadata.creator || 'æœªçŸ¥'));
                    
                    const smilItems = Object.values(manifest).filter(item => 
                        item && 
                        (
                            item.type === 'application/smil+xml' || 
                            item.type === 'application/smil' ||
                            (item.href && (item.href.includes('.smil') || (item.id && item.id.includes('smil'))))
                        )
                    );
                    
                    this.updateInfo('- æ‰¾åˆ° ' + smilItems.length + ' ä¸ªSMILæ–‡ä»¶');
                    
                    if (smilItems.length === 0) {
                        this.updateStatus("âŒ æœªæ‰¾åˆ°SMILæ–‡ä»¶", 'error');
                        return;
                    }
                    
                    smilItems.forEach((item, index) => {
                        this.updateInfo('&nbsp;&nbsp;' + (index + 1) + '. ' + item.href + ' (ID: ' + item.id + ')');
                    });
                    
                    await this.buildPlaybackQueue(smilItems); 
                    
                    if (this.queue.length === 0) {
                        this.updateStatus("âŒ æ— æ³•è§£ææœ‰æ•ˆçš„åª’ä½“è¦†ç›–æ•°æ®", 'error');
                        return;
                    }

                    this.updateStatus('âœ… åŠ è½½å®Œæˆï¼Œæ‰¾åˆ° ' + this.queue.length + ' ä¸ªåŒæ­¥ç‰‡æ®µ');
                    
                    this.audioGroups = this.groupFragmentsByAudio();
                    this.updateInfo('<strong>éŸ³é¢‘æ–‡ä»¶ç»Ÿè®¡:</strong>');
                    this.audioGroups.forEach((fragments, audioFile) => {
                        this.updateInfo('- ' + audioFile + ': ' + fragments.length + ' ä¸ªç‰‡æ®µ');
                    });
                    
                    const firstFragment = this.queue[0];
                    if (firstFragment) {
                        await this.displayFragmentPage(firstFragment);
                    }

                } catch (error) {
                    this.updateStatus('âŒ åˆå§‹åŒ–å¤±è´¥: ' + error.message, 'error');
                    console.error("Player Initialization Error:", error);
                }
            }
            
            // --- æ„å»ºæ’­æ”¾é˜Ÿåˆ— (å¹¶è¡Œå¤„ç†) ---
            async buildPlaybackQueue(smilItems) { 
                this.queue = [];
                this.updateInfo('<strong>=== å¼€å§‹å¹¶è¡Œå¤„ç†SMILæ–‡ä»¶ (é€Ÿåº¦ä¼˜åŒ–) ===</strong>');
                
                const processingPromises = smilItems.map(smilItem => this.processSingleSmilFile(smilItem));

                const results = await Promise.allSettled(processingPromises);

                let totalFragments = 0;
                
                results.forEach(result => {
                    if (result.status === 'fulfilled' && result.value) {
                        totalFragments += result.value.fragmentsAdded;
                        this.queue.push(...result.value.fragments);
                        this.updateInfo(`âœ… æ·»åŠ äº† ${result.value.fragmentsAdded} ä¸ªç‰‡æ®µ (SMIL: ${result.value.smilHref})`);
                    } else if (result.status === 'rejected') {
                        const error = result.reason;
                        this.updateInfo(`<span class="error">âŒ å¤„ç†å¤±è´¥: ${error.message}</span>`);
                    }
                });

                this.updateInfo('<h3>ğŸ‰ å®Œæˆ! æ€»å…±æ”¶é›†åˆ° ' + totalFragments + ' ä¸ªåŒæ­¥ç‰‡æ®µ</h3>');
            }

            // --- å¤„ç†å•ä¸ª SMIL æ–‡ä»¶çš„å‡½æ•° ---
            async processSingleSmilFile(smilItem) {
                this.updateInfo('æ­£åœ¨è¯»å–: ' + smilItem.href);
                
                try {
                    const absolutePath = this.resolveSmilPath(smilItem.href);
                    const content = await this.book.archive.getText(absolutePath);
                    
                    if (!content) {
                        throw new Error('SMIL æ–‡ä»¶å†…å®¹è¯»å–å¤±è´¥ã€‚');
                    }
                    
                    const fragments = [];
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(content, "application/xml");
                    
                    const parseError = xmlDoc.getElementsByTagName("parsererror")[0];
                    if (parseError) {
                        throw new Error('XMLè§£æé”™è¯¯: ' + parseError.textContent);
                    }
                    
                    const parElements = xmlDoc.getElementsByTagName('par');
                    
                    let fragmentsAdded = 0;
                    
                    for (let par of parElements) {
                        const textElements = par.getElementsByTagName('text');
                        const audioElements = par.getElementsByTagName('audio');
                        
                        if (textElements.length > 0 && audioElements.length > 0) {
                            const text = textElements[0];
                            const audio = audioElements[0];
                            
                            let textSrc = text.getAttribute('src');
                            let audioSrc = audio.getAttribute('src');
                            const clipBegin = audio.getAttribute('clipBegin') || audio.getAttribute('clip-begin');
                            const clipEnd = audio.getAttribute('clipEnd') || audio.getAttribute('clip-end');
                            
                            if (textSrc && audioSrc) {
                                // resolvePath ç°åœ¨è¿”å›å¸¦æ–œæ çš„ç»å¯¹è·¯å¾„
                                const resolvedTextSrc = this.resolvePath(textSrc, smilItem.href);
                                const resolvedAudioSrc = this.resolvePath(audioSrc, smilItem.href);
                                
                                fragments.push({
                                    textSrc: resolvedTextSrc,
                                    audioSrc: resolvedAudioSrc,
                                    clipBegin: clipBegin,
                                    clipEnd: clipEnd,
                                    originalIndex: fragmentsAdded,
                                    smilFile: smilItem.href
                                });
                                
                                fragmentsAdded++;
                                
                                if (fragmentsAdded <= 3) {
                                    this.updateInfo(`&nbsp;&nbsp;&nbsp;&nbsp;ç‰‡æ®µ ${fragmentsAdded} (SMIL: ${smilItem.href}): ${textSrc} -> ${audioSrc}`);
                                }
                            }
                        }
                    }
                    
                    return { 
                        fragments, 
                        fragmentsAdded,
                        smilHref: smilItem.href
                    };
                    
                } catch (error) {
                    throw new Error(`SMILæ–‡ä»¶ ${smilItem.href} å¤„ç†å¤±è´¥: ${error.message}`);
                }
            }

            // --- SMIL è·¯å¾„è§£æ (è¿”å›ç›¸å¯¹äº EPUB æ ¹ç›®å½•ï¼Œå¸¦ '/') ---
            resolveSmilPath(smilPath) {
                if (smilPath.startsWith('/')) {
                    return smilPath;
                }
                
                const packagePath = this.book.container.packagePath;
                if (!packagePath) {
                    return '/' + smilPath;
                }
                
                // è·å– OPF æ–‡ä»¶æ‰€åœ¨çš„ç›®å½•ï¼Œå¹¶é™„åŠ  SMIL è·¯å¾„
                let baseDir = packagePath.includes('/') 
                    ? packagePath.substring(0, packagePath.lastIndexOf('/') + 1)
                    : '';
                
                // V13 ä¿®å¤: ç¡®ä¿è¿”å›çš„è·¯å¾„æ˜¯ç»å¯¹è·¯å¾„
                let finalPath = baseDir + smilPath;
                if (!finalPath.startsWith('/')) {
                    finalPath = '/' + finalPath;
                }
                
                return finalPath;
            }

            // --- æ ¸å¿ƒè·¯å¾„è§£ææ–¹æ³• (è¿”å›ç›¸å¯¹äº EPUB æ ¹ç›®å½•çš„è·¯å¾„ï¼Œå¸¦ '/') ---
            resolvePath(relativePath, baseFile) {
                if (!relativePath) return '';
                
                // 1. å¦‚æœè·¯å¾„å·²æ˜¯ç»å¯¹è·¯å¾„ (å¸¦æ–œæ )ï¼Œç›´æ¥è¿”å›
                if (relativePath.startsWith('/')) {
                    return relativePath;
                }

                // 2. è·å–åŸºå‡†ç›®å½•
                const baseDir = baseFile.substring(0, baseFile.lastIndexOf('/') + 1);
                
                let fullPath = baseDir + relativePath;

                // 3. å¤„ç†ç›¸å¯¹è·¯å¾„ (.. å’Œ .)
                const pathParts = fullPath.split('/');
                const resolvedParts = [];
                
                for (const part of pathParts) {
                    if (part === '..') {
                        if (resolvedParts.length > 0 && resolvedParts[resolvedParts.length - 1] !== '..') {
                            resolvedParts.pop();
                        }
                    } else if (part !== '.' && part !== '') {
                        resolvedParts.push(part);
                    }
                }
                
                // 4. å¼ºåˆ¶æ·»åŠ å‰å¯¼æ–œæ ï¼Œè¿”å›ç»å¯¹è·¯å¾„
                let finalPath = '/' + resolvedParts.join('/');

                if (finalPath.startsWith('//')) {
                    finalPath = finalPath.substring(1);
                }
                
                return finalPath;
            }

            // --- éŸ³é¢‘æ–‡ä»¶åˆ†ç»„ ---
            groupFragmentsByAudio() {
                const groups = new Map();
                
                this.queue.forEach((fragment, index) => {
                    const audioFile = fragment.audioSrc;
                    if (!groups.has(audioFile)) {
                        groups.set(audioFile, []);
                    }
                    groups.get(audioFile).push({
                        ...fragment,
                        originalIndex: index
                    });
                });
                
                return groups;
            }

            // --- éŸ³é¢‘URLè·å–æ–¹æ³• (ã€æœ€ç»ˆä¿®å¤ V13ã€‘è·¯å¾„ä¿®å¤ï¼Œä¾èµ– resolvePath è¿”å›ç»å¯¹è·¯å¾„) ---
            async getAudioUrl(audioPath) {
                // audioPath ç°åœ¨æ˜¯å¸¦å‰å¯¼æ–œæ çš„è·¯å¾„ (e.g., /OEBPS/Audio/00000-00001.mp4 æˆ– /Audio/...)
                let internalPath = audioPath.startsWith('/') ? audioPath.substring(1) : audioPath;
                
                // 1. åˆå§‹åŒ–è·¯å¾„å°è¯•åˆ—è¡¨
                const pathsToTest = [];

                // 2. æ·»åŠ åŸå§‹è§£æç»“æœ (ç»å¯¹è·¯å¾„å’Œç›¸å¯¹è·¯å¾„)
                pathsToTest.push('/' + internalPath); // /OEBPS/Audio/...
                pathsToTest.push(internalPath); // OEBPS/Audio/...

                // 3. æ¸…ç†è·¯å¾„ï¼ˆå¦‚æœ internalPath åŒ…å« OEBPS/ æˆ– OPS/ï¼Œå°è¯•å»é™¤ï¼‰
                let cleanedPath = internalPath;
                if (cleanedPath.toLowerCase().startsWith('oebps/') || cleanedPath.toLowerCase().startsWith('ops/')) {
                    const parts = cleanedPath.split('/');
                    parts.shift(); // ç§»é™¤ OEBPS æˆ– OPS
                    cleanedPath = parts.join('/');
                    pathsToTest.push(cleanedPath); // Audio/...
                    pathsToTest.push('/' + cleanedPath); // /Audio/...
                }
                
                // 4. è·¯å¾„çŒœæµ‹ï¼šå¢åŠ  OPS/ OEBPS/ å‰ç¼€ (ä»¥é˜²åŸå§‹è§£ææœªåŒ…å«)
                const primaryPrefixes = ['OEBPS', 'OPS'];
                for (const prefix of primaryPrefixes) {
                    // a) OEBPS/Audio/... (ä¸å¸¦æ–œæ ï¼ŒEPUBå†…éƒ¨ç²¾ç¡®é”®å)
                    if (!internalPath.startsWith(prefix + '/')) {
                        pathsToTest.push(prefix + '/' + internalPath); 
                        // b) /OEBPS/Audio/... (å¸¦æ–œæ ï¼Œç»å¯¹è·¯å¾„å½¢å¼)
                        pathsToTest.push('/' + prefix + '/' + internalPath); 
                    }
                }

                // 5. è¿›è¡Œæ‰€æœ‰è·¯å¾„çš„å°è¯•
                const finalPaths = [...new Set(pathsToTest)]; // å»é‡

                for (const pathForArchive of finalPaths) {
                    
                    this.updateInfo(`   å°è¯•è·å–éŸ³é¢‘: ${pathForArchive}`); 

                    // --- å°è¯• Blob è·å– (ä¼˜å…ˆ) ---
                    try {
                        const blob = await this.book.archive.getBlob(pathForArchive); 
                        const url = URL.createObjectURL(blob);
                        this.updateInfo(`âœ… éŸ³é¢‘URLè·å–æˆåŠŸ (Blob): ${pathForArchive}`);
                        return url;
                    } catch (error) {
                        // å¿½ç•¥ Blob å¤±è´¥
                    }
                }
                
                // 6. å¦‚æœæ‰€æœ‰å°è¯•éƒ½å¤±è´¥ï¼ŒæŠ›å‡ºé”™è¯¯
                throw new Error('File not found in the epub: ' + internalPath);
            }

            // --- æ˜¾ç¤ºç‰‡æ®µé¡µé¢ (ã€V14 ä¿®æ­£ã€‘ä¿®å¤ goTo é”™è¯¯) ---
            async displayFragmentPage(fragment) {
                try {
                    // fragment.textSrc æ˜¯å¸¦IDçš„ç»å¯¹è·¯å¾„ (e.g., /OEBPS/Text/chap.html#id)
                    const htmlPathWithId = fragment.textSrc;
                    const htmlPath = htmlPathWithId.split('#')[0]; // /OEBPS/Text/chap.html
                    
                    // Epub.js Rendition display æ–¹æ³•æ¥å—ç›¸å¯¹è·¯å¾„ (ä¸å¸¦æ–œæ ) æˆ– manifest/spine ä¸­çš„ href
                    // æˆ‘ä»¬éœ€è¦ä¼ é€’ä¸€ä¸ªä¸å¸¦æ–œæ çš„è·¯å¾„ç»™ spine.get
                    const calculatedDisplayPath = htmlPath.startsWith('/') ? htmlPath.substring(1) : htmlPath;
                    
                    
                    let section = this.book.spine.get(calculatedDisplayPath);
                    
                    // æ¸²æŸ“æ—¶ä½¿ç”¨çš„è·¯å¾„ï¼šä½¿ç”¨ manifest/spine ä¸­çš„ hrefï¼Œå¦‚æœæ‰¾ä¸åˆ°åˆ™ä½¿ç”¨è®¡ç®—å‡ºçš„ä¸å¸¦æ–œæ è·¯å¾„
                    const renderPath = section ? section.href : calculatedDisplayPath; 

                    if (!section) {
                         this.updateInfo('<span class="warning">âš ï¸ Spineæœªæ‰¾åˆ°Section (' + calculatedDisplayPath + ')ï¼Œå°è¯•åŸå§‹è·¯å¾„æ¸²æŸ“ã€‚</span>');
                    }
                    
                    const currentLocation = this.rendition.currentLocation();
                    
                    // æ£€æŸ¥å½“å‰é¡µé¢æ˜¯å¦å·²ç»æ˜¯ç›®æ ‡é¡µé¢ï¼Œé˜²æ­¢ä¸å¿…è¦çš„é‡ç»˜
                    if (currentLocation && currentLocation.start && currentLocation.start.href.includes(renderPath)) {
                        this.updateInfo('é¡µé¢å·²æ˜¾ç¤º: ' + renderPath);
                    } else {
                        this.updateInfo('æ˜¾ç¤ºé¡µé¢: ' + renderPath);
                        
                        // ä½¿ç”¨ renderPath è¿›è¡Œæ˜¾ç¤º (ä¸å¸¦ ID)
                        await this.rendition.display(renderPath);
                        
                        // ç»™äºˆæµè§ˆå™¨/æ¸²æŸ“å™¨ç¼“å†²æ—¶é—´
                        await new Promise(resolve => setTimeout(resolve, 500)); 
                    }
                    
                    // V14 ä¿®æ­£: å¼ºåˆ¶æ»šåŠ¨åˆ°æ­£ç¡®çš„ä½ç½®ã€‚æˆ‘ä»¬å°è¯•ä½¿ç”¨ display æˆ– goToã€‚
                    try {
                        // V14 å°è¯• 1: ä½¿ç”¨ display æ–¹æ³•è·³è½¬åˆ° ID é”šç‚¹ (å¦‚æœé¡µé¢å·²åŠ è½½ï¼Œè¿™åº”è¯¥åªè§¦å‘æ»šåŠ¨)
                        await this.rendition.display(htmlPathWithId); 
                        this.updateInfo(`âœ… æ»šåŠ¨è‡³ç‰‡æ®µ (Display): ${htmlPathWithId}`);
                    } catch (e) {
                         // V14 å°è¯• 2: å¦‚æœ display å¤±è´¥ï¼Œå°è¯•æ›´ç›´æ¥çš„ location.goToï¼ˆå¦‚æœå®ƒå­˜åœ¨ï¼‰
                         if (this.rendition.location && typeof this.rendition.location.goTo === 'function') {
                             this.rendition.location.goTo(htmlPathWithId);
                             this.updateInfo(`âœ… æ»šåŠ¨è‡³ç‰‡æ®µ (goTo): ${htmlPathWithId}`);
                         } else {
                             // å¿½ç•¥ï¼Œåœ¨åˆæ¬¡åŠ è½½æ—¶ç»å¸¸å¤±è´¥
                             console.warn("æ— æ³•æ»šåŠ¨åˆ°IDé”šç‚¹:", e);
                         }
                    }


                } catch (error) {
                    console.error('æ˜¾ç¤ºé¡µé¢å¤±è´¥:', error);
                    this.updateInfo('<p class="error">âŒ æ˜¾ç¤ºé¡µé¢å¤±è´¥: ' + error.message + '</p>');
                    throw error; 
                }
            }

            // --- æ’­æ”¾æ§åˆ¶ ---
            async play() {
                if (this.queue.length === 0) return;

                this.isPlaying = true;
                this.updateStatus("â–¶ï¸ æ­£åœ¨æ’­æ”¾...");
                
                if (this.currentAudioFile) {
                    try {
                        await this.audioElement.play();
                        this.updateStatus('â–¶ï¸ æ­£åœ¨æ’­æ”¾: ' + this.currentAudioFile);
                    } catch (e) {
                        this.updateStatus("âš ï¸ é‡æ–°å¯åŠ¨æ’­æ”¾æµç¨‹...");
                        await this.playByAudioFiles();
                    }
                } else {
                    await this.playByAudioFiles();
                }
            }

            pause() {
                this.isPlaying = false;
                this.audioElement.pause();
                this.updateStatus("â¸ï¸ å·²æš‚åœ");
            }

            stop() {
                this.isPlaying = false;
                this.audioElement.pause();
                this.audioElement.currentTime = 0;
                this.highlightCurrentFragment(false);
                this.currentIndex = -1;
                this.currentAudioFile = null;
                this.updateStatus("â¹ï¸ å·²åœæ­¢");
                this.updateFragmentId("N/A");
                document.getElementById('progress-bar').style.width = '0%';
                document.getElementById('time-display').textContent = '00:00 / 00:00';
            }

            async playByAudioFiles() {
                if (this.audioGroups.size === 0) return;
                
                let currentGroupsArray = Array.from(this.audioGroups);
                
                let startIndex = 0;
                if (this.currentAudioFile) {
                    startIndex = currentGroupsArray.findIndex(([file, fragments]) => file === this.currentAudioFile);
                    if (startIndex === -1) startIndex = 0;
                }

                for (let i = startIndex; i < currentGroupsArray.length; i++) {
                    const [audioFile, fragments] = currentGroupsArray[i];
                    
                    if (!this.isPlaying) break;
                    
                    this.currentAudioFile = audioFile;
                    this.updateInfo('<strong>å¼€å§‹æ’­æ”¾éŸ³é¢‘: ' + audioFile + '</strong>');
                    
                    if (fragments.length > 0) {
                        await this.displayFragmentPage(fragments[0]);
                    }
                    
                    try {
                        await this.playAudioFile(audioFile, fragments);
                    } catch (error) {
                        this.updateInfo(`<span class="error">â© è·³è¿‡æ–‡ä»¶ ${audioFile}ï¼Œç»§ç»­ä¸‹ä¸€ä¸ªéŸ³é¢‘ç»„ã€‚</span>`);
                        continue; 
                    }
                }
                
                if (this.isPlaying) {
                    this.isPlaying = false;
                    this.updateStatus("âœ… æ‰€æœ‰éŸ³é¢‘æ’­æ”¾å®Œæˆ");
                }
                this.currentAudioFile = null;
                this.currentIndex = -1;
            }

            // --- æ’­æ”¾å•ä¸ªéŸ³é¢‘æ–‡ä»¶ ---
            async playAudioFile(audioFile, fragments) {
                try {
                    // audioFile here is the resolved absolute path (e.g., /Audio/00000-00001.mp4)
                    if (this.audioElement.src.indexOf(audioFile) === -1 || !this.audioElement.src) {
                        const audioUrl = await this.getAudioUrl(audioFile);
                        this.audioElement.src = audioUrl;
                        this.audioElement.currentTime = 0;
                    }
                    
                    if (this.currentIndex >= 0) {
                        this.highlightCurrentFragment(false, this.currentIndex);
                    }
                    this.currentIndex = -1;
                    this.updateFragmentId("å‡†å¤‡æ’­æ”¾...");
                    
                    await this.audioElement.play();
                    this.updateStatus('â–¶ï¸ æ­£åœ¨æ’­æ”¾: ' + audioFile);
                    
                    await new Promise((resolve) => {
                        const onAudioEnd = () => {
                            this.audioElement.removeEventListener('ended', onAudioEnd);
                            resolve();
                        };
                        
                        this.audioElement.addEventListener('ended', onAudioEnd);

                        const checkState = setInterval(() => {
                            if (!this.isPlaying || this.audioElement.ended) {
                                clearInterval(checkState);
                                this.audioElement.removeEventListener('ended', onAudioEnd);
                                resolve();
                            }
                        }, 100);
                    });
                    
                } catch (error) {
                    console.error('æ’­æ”¾éŸ³é¢‘å¤±è´¥: ' + audioFile, error);
                    this.updateStatus('âŒ æ’­æ”¾å¤±è´¥: ' + audioFile, 'error');
                    this.updateInfo('<span class="error">æ’­æ”¾å¤±è´¥è¯¦æƒ…: ' + error.message + '</span>');
                    throw error; 
                }
            }

            // --- å®æ—¶é«˜äº®ç³»ç»Ÿ ---
            updateCurrentHighlight() {
                if (!this.isPlaying || !this.currentAudioFile) return;
                
                const currentTime = this.audioElement.currentTime;
                this.updateProgressBar();
                
                const currentFragment = this.findFragmentByTime(currentTime);
                
                if (currentFragment && currentFragment.index !== this.currentIndex) {
                    
                    if (this.currentIndex >= 0) {
                        this.highlightCurrentFragment(false, this.currentIndex);
                    }
                    
                    this.currentIndex = currentFragment.index;
                    
                    const success = this.highlightCurrentFragment(true, this.currentIndex);
                    this.updateFragmentId(currentFragment.fragmentId + (success ? '' : ' (æ‰¾ä¸åˆ°å…ƒç´ )'));
                    
                    if (success) {
                        const fragment = this.queue[this.currentIndex];
                        // æ»šåŠ¨åˆ°å½“å‰ç‰‡æ®µ (åœ¨é¡µé¢å·²åŠ è½½åï¼Œè¿™ä¸ªè°ƒç”¨é€šå¸¸æ˜¯å®‰å…¨çš„)
                        if (this.rendition.location && typeof this.rendition.location.goTo === 'function') {
                            this.rendition.location.goTo(fragment.textSrc);
                        } else {
                            // å¤‡ç”¨æ–¹æ¡ˆï¼Œå†æ¬¡å°è¯• display
                            this.rendition.display(fragment.textSrc);
                        }
                    }
                }
            }

            findFragmentByTime(currentTime) {
                const fragments = this.audioGroups.get(this.currentAudioFile) || [];
                
                for (let i = 0; i < fragments.length; i++) {
                    const fragment = fragments[i];
                    const startTime = this.timeToSeconds(fragment.clipBegin);
                    const endTime = this.timeToSeconds(fragment.clipEnd);
                    
                    if (currentTime >= startTime && currentTime < endTime) {
                        const textParts = fragment.textSrc.split('#');
                        const fragmentId = textParts.length > 1 ? textParts[1] : 'fragment-' + i;
                        return {
                            index: fragment.originalIndex,
                            fragmentId: fragmentId,
                            startTime: startTime,
                            endTime: endTime
                        };
                    }
                }
                return null;
            }

            highlightCurrentFragment(highlight, index = this.currentIndex) {
                const fragment = this.queue[index];
                if (!fragment) return false;
                
                const textParts = fragment.textSrc.split('#');
                const fragmentId = textParts.length > 1 ? textParts[1] : null;
                if (!fragmentId) return false;

                try {
                    let targetDoc = null;
                    
                    if (this.rendition && this.rendition.getContents) {
                        const contents = this.rendition.getContents();
                        if (contents && contents.length > 0) {
                            targetDoc = contents[0].document;
                        }
                    }
                    
                    if (!targetDoc) return false;
                    
                    const targetEl = targetDoc.getElementById(fragmentId);
                    
                    if (targetEl) {
                        targetEl.classList.toggle(this.activeClass, highlight);
                        return true;
                    }
                    
                    return false;
                    
                } catch (e) {
                    console.warn("é«˜äº®å¤±è´¥ï¼Œå¯èƒ½å…ƒç´ ä¸åœ¨å½“å‰æ¸²æŸ“é¡µ:", e);
                    return false;
                }
            }

            updateProgressBar() {
                if (this.audioElement.duration) {
                    const progress = (this.audioElement.currentTime / this.audioElement.duration) * 100;
                    document.getElementById('progress-bar').style.width = progress + '%';
                    
                    const currentTime = this.formatTime(this.audioElement.currentTime);
                    const totalTime = this.formatTime(this.audioElement.duration);
                    document.getElementById('time-display').textContent = currentTime + ' / ' + totalTime;
                }
            }

            seekForward() {
                if (this.audioElement.duration) {
                    this.audioElement.currentTime = Math.min(
                        this.audioElement.currentTime + 10,
                        this.audioElement.duration
                    );
                }
            }

            seekBackward() {
                if (this.audioElement.duration) {
                    this.audioElement.currentTime = Math.max(
                        this.audioElement.currentTime - 10,
                        0
                    );
                }
            }

            formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return mins.toString().padStart(2, '0') + ':' + secs.toString().padStart(2, '0');
            }

            updateStatus(message, type = 'success') {
                const statusEl = document.getElementById('player-status');
                statusEl.innerHTML = '<span class="' + type + '">' + message + '</span>';
            }

            updateFragmentId(id) {
                document.getElementById('current-fragment-id').textContent = id;
            }

            updateInfo(message) {
                 this.infoOutput.innerHTML += '<p style="margin: 2px 0; font-size: 12px;">' + message + '</p>';
            }
        }
        
        // --- æ–‡ä»¶åŠ è½½å‡½æ•° ---
        async function loadEPUB() {
            const fileInput = document.getElementById('epub-file');
            const file = fileInput.files[0];
            
            if (!file) {
                alert('è¯·é€‰æ‹©EPUBæ–‡ä»¶');
                return;
            }

            try {
                document.getElementById('info-output').innerHTML = '<p>æ­£åœ¨åŠ è½½EPUBæ–‡ä»¶...</p>';
                
                book = ePub(file);
                
                // æ·»åŠ  iframeSandbox æƒé™
                rendition = book.renderTo("viewer", { 
                    width: "100%", 
                    height: "100%",
                    flow: "scrolled-doc",
                    iframeSandbox: 'allow-scripts allow-same-origin' 
                });
                
                await book.opened;
                
                document.getElementById('info-output').innerHTML = '<p class="success">EPUBæ–‡ä»¶åŠ è½½æˆåŠŸï¼Œæ­£åœ¨è§£æåª’ä½“è¦†ç›–ä¿¡æ¯...</p>';
                
                player = new MediaOverlayPlayer(book, rendition, document.getElementById('info-output'));
                await player.initialize();
                
                // ç»‘å®šæ§åˆ¶äº‹ä»¶
                document.getElementById('play-pause-btn').onclick = () => {
                    if (player && player.queue.length > 0) {
                        if (player.isPlaying) {
                            player.pause();
                        } else {
                            player.play();
                        }
                    } else {
                        player.updateStatus("âš ï¸ æœªåŠ è½½æœ‰æ•ˆçš„åŒæ­¥æ•°æ®", 'warning');
                    }
                };
                document.getElementById('stop-btn').onclick = () => player && player.stop();
                document.getElementById('seek-back-btn').onclick = () => player && player.seekBackward();
                document.getElementById('seek-forward-btn').onclick = () => player && player.seekForward();
                
            } catch (error) {
                document.getElementById('info-output').innerHTML = '<p class="error">âŒ åŠ è½½å¤±è´¥: ' + error.message + '</p>';
                console.error("EPUBåŠ è½½é”™è¯¯:", error);
            }
        }

        // --- åˆå§‹åŒ–äº‹ä»¶ç›‘å¬ ---
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('load-btn').addEventListener('click', loadEPUB);
            
            document.getElementById('epub-file').addEventListener('change', function() {
                if (this.files.length > 0) {
                    document.getElementById('load-btn').disabled = false;
                }
            });
            document.getElementById('load-btn').disabled = true; 
        });
    </script>
</body>
</html>