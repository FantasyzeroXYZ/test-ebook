<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Epub.js Media Overlay Player - è¿ç»­æ’­æ”¾ç‰ˆ</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://unpkg.com/epubjs/dist/epub.min.js"></script>
    
    <style>
        body { font-family: sans-serif; margin: 20px; }
        #controls { text-align: center; margin-bottom: 20px; }
        #viewer { width: 80%; height: 500px; margin: 20px auto; border: 1px solid #ccc; }
        .data-box { background: #f4f4f4; padding: 15px; border: 1px dashed #aaa; margin-top: 10px; max-height: 400px; overflow-y: auto; }
        .mo-active { 
            background-color: #ffda6a; 
            padding: 1px 3px; 
            border-radius: 3px;
            box-shadow: 0 0 5px rgba(255, 218, 106, 0.5);
            transition: all 0.3s ease;
        }
        .error { color: red; font-weight: bold; }
        .success { color: green; }
        .warning { color: orange; }
        button { padding: 10px 20px; margin: 0 5px; cursor: pointer; }
        
        #viewer .epub-container {
            line-height: 1.6;
            padding: 20px;
        }
        #viewer .epub-container p {
            margin: 0.5em 0;
        }
        
        .progress-container {
            width: 80%;
            margin: 10px auto;
            background: #f0f0f0;
            border-radius: 10px;
            height: 8px;
        }
        .progress-bar {
            height: 100%;
            background: #4CAF50;
            border-radius: 10px;
            width: 0%;
            transition: width 0.1s ease;
        }
    </style>
</head>
<body>

    <h1>ğŸ™ï¸ EPUB3 Media Overlay Player (è¿ç»­æ’­æ”¾ç‰ˆ)</h1>

    <div id="controls">
        <button id="play-pause-btn">â–¶ï¸ æ’­æ”¾ / æš‚åœ</button>
        <button id="stop-btn">â¹ï¸ åœæ­¢</button>
        <button id="seek-back-btn">âª å¿«é€€10ç§’</button>
        <button id="seek-forward-btn">â© å¿«è¿›10ç§’</button>
        <p>å½“å‰çŠ¶æ€: <span id="player-status">æœªåŠ è½½</span> | ç‰‡æ®µ: <span id="current-fragment-id">N/A</span></p>
        <div class="progress-container">
            <div class="progress-bar" id="progress-bar"></div>
        </div>
        <p id="time-display">00:00 / 00:00</p>
    </div>

    <div id="viewer"></div>

    <div class="data-box" id="info-output">æ­£åœ¨åŠ è½½ Epub.js å’Œ EPUB æ–‡ä»¶...</div>

    <script>
        // --- å…¨å±€å˜é‡å’Œé…ç½® ---
        const EPUB_PATH = "book.epub"; 
        const HIGHLIGHT_CLASS = 'mo-active'; 
        
        let book;
        let rendition;
        let player; 

        // --- MediaOverlayPlayer ç±»å®šä¹‰ ---

        class MediaOverlayPlayer {
            constructor(book, rendition, infoOutput) {
                this.book = book;
                this.rendition = rendition;
                this.infoOutput = infoOutput;
                this.queue = [];      
                this.currentIndex = -1;
                this.isPlaying = false;
                this.audioElement = new Audio();
                this.activeClass = HIGHLIGHT_CLASS;
                
                // å®æ—¶é«˜äº®æ£€æµ‹
                this.audioElement.ontimeupdate = this.updateCurrentHighlight.bind(this);
                this.audioElement.onended = () => {
                    this.isPlaying = false;
                    this.updateStatus("âœ… æ’­æ”¾ç»“æŸ");
                };
                
                this.currentAudioFile = null;
                this.audioGroups = new Map();
            }

            // --- è¾…åŠ©å‡½æ•°ï¼šæ—¶é—´æ ¼å¼è½¬æ¢ ---
            timeToSeconds(timeStr) {
                if (!timeStr) return 0;
                if (timeStr.endsWith('s')) {
                    return parseFloat(timeStr.slice(0, -1));
                }
                const parts = timeStr.split(':').map(parseFloat);
                if (parts.length === 3) {
                    return parts[0] * 3600 + parts[1] * 60 + parts[2];
                }
                return parseFloat(timeStr); 
            }

            // --- æ ¸å¿ƒåˆå§‹åŒ–å’Œè§£æ ---

            async initialize() {
                this.updateStatus("æ­£åœ¨è§£æ EPUB ç»“æ„...");
                
                try {
                    const [metadata, manifest, spine, navigation] = await Promise.all([
                        this.book.loaded.metadata,
                        this.book.loaded.manifest,
                        this.book.loaded.spine,
                        this.book.loaded.navigation
                    ]);
                    
                    this.activeClass = metadata.media_active_class || HIGHLIGHT_CLASS;
                    this.updateInfo(`<span class="success">å…ƒæ•°æ®åŠ è½½æˆåŠŸ</span>`);
                    
                    // æ˜¾ç¤ºæ‰€æœ‰SMILç›¸å…³æ–‡ä»¶
                    const smilItems = Object.values(manifest).filter(item => 
                        item.type === 'application/smil+xml' || 
                        item.type === 'application/smil' ||
                        item.href.includes('.smil')
                    );
                    
                    this.updateInfo(`- æ‰¾åˆ° ${smilItems.length} ä¸ªSMILæ–‡ä»¶`);
                    
                    await this.buildPlaybackQueue(smilItems); 
                    
                    if (this.queue.length === 0) {
                        this.updateStatus("âŒ æ— æ³•æ‰¾åˆ°æœ‰æ•ˆçš„åª’ä½“è¦†ç›–æ•°æ®", 'error');
                        return;
                    }

                    this.updateStatus(`âœ… åŠ è½½å®Œæˆï¼Œæ‰¾åˆ° ${this.queue.length} ä¸ªåŒæ­¥ç‰‡æ®µ`);
                    
                    // æŒ‰éŸ³é¢‘æ–‡ä»¶åˆ†ç»„
                    this.audioGroups = this.groupFragmentsByAudio();
                    this.updateInfo(`<strong>éŸ³é¢‘æ–‡ä»¶ç»Ÿè®¡:</strong>`);
                    this.audioGroups.forEach((fragments, audioFile) => {
                        this.updateInfo(`- ${audioFile}: ${fragments.length} ä¸ªç‰‡æ®µ`);
                    });
                    
                    // æ˜¾ç¤ºç¬¬ä¸€ä¸ªé¡µé¢
                    const firstFragment = this.queue[0];
                    if (firstFragment) {
                        let textSrc = firstFragment.textSrc;
                        if (textSrc.startsWith('../')) {
                            textSrc = textSrc.substring(3);
                        }
                        const [htmlFile] = textSrc.split('#');
                        
                        await this.rendition.display(htmlFile);
                        await new Promise(resolve => setTimeout(resolve, 500));
                    }

                } catch (error) {
                    this.updateStatus(`âŒ åˆå§‹åŒ–å¤±è´¥: ${error.message}`, 'error');
                    console.error("Player Initialization Error:", error);
                }
            }
            
            // =========================================================================
            // ===>>> SMILæ–‡ä»¶å¤„ç† <<<===
            // =========================================================================
            async buildPlaybackQueue(smilItems) { 
                this.queue = [];
                
                this.updateInfo(`<strong>=== å¼€å§‹å¤„ç†SMILæ–‡ä»¶ ===</strong>`);
                
                let totalFragments = 0;
                
                for (const smilItem of smilItems) {
                    try {
                        this.updateInfo(`å¤„ç†: ${smilItem.href}`);
                        
                        // ä½¿ç”¨ç»å¯¹è·¯å¾„è¯»å–
                        const absolutePath = `/${smilItem.href}`;
                        const content = await this.book.archive.getText(absolutePath);
                        
                        if (!content) {
                            this.updateInfo(`<span class="error">âŒ è¯»å–å¤±è´¥</span>`);
                            continue;
                        }
                        
                        this.updateInfo(`âœ… æ–‡ä»¶è¯»å–æˆåŠŸ (${content.length} å­—ç¬¦)`);
                        
                        // è§£æSMILå†…å®¹
                        const fragments = await this.parseSmilContent(content, smilItem.href);
                        totalFragments += fragments;
                        
                        this.updateInfo(`âœ… æ·»åŠ äº† ${fragments} ä¸ªç‰‡æ®µ`);
                        
                    } catch (error) {
                        this.updateInfo(`<span class="error">âŒ å¤„ç†å¤±è´¥: ${error.message}</span>`);
                    }
                }
                
                this.updateInfo(`<h3>ğŸ‰ å®Œæˆ! æ€»å…±æ”¶é›†åˆ° ${totalFragments} ä¸ªåŒæ­¥ç‰‡æ®µ</h3>`);
            }
                        
            // è§£æSMILå†…å®¹
            async parseSmilContent(smilContent, smilHref) {
                try {
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(smilContent, "application/xml");
                    
                    const parseError = xmlDoc.getElementsByTagName("parsererror")[0];
                    if (parseError) {
                        this.updateInfo(`<span class="error">âŒ XMLè§£æé”™è¯¯</span>`);
                        return 0;
                    }
                    
                    const parElements = xmlDoc.getElementsByTagName('par');
                    this.updateInfo(`- æ‰¾åˆ° ${parElements.length} ä¸ªparå…ƒç´ `);
                    
                    let fragmentsAdded = 0;
                    
                    // æ·»åŠ åˆ°é˜Ÿåˆ—
                    for (let par of parElements) {
                        const textElements = par.getElementsByTagName('text');
                        const audioElements = par.getElementsByTagName('audio');
                        
                        if (textElements.length > 0 && audioElements.length > 0) {
                            const text = textElements[0];
                            const audio = audioElements[0];
                            
                            let textSrc = text.getAttribute('src');
                            let audioSrc = audio.getAttribute('src');
                            const clipBegin = audio.getAttribute('clipBegin') || audio.getAttribute('clip-begin');
                            const clipEnd = audio.getAttribute('clipEnd') || audio.getAttribute('clip-end');
                            
                            // ä¿®å¤è·¯å¾„
                            if (textSrc && textSrc.startsWith('../')) {
                                textSrc = textSrc.substring(3);
                            }
                            if (audioSrc && audioSrc.startsWith('../')) {
                                audioSrc = audioSrc.substring(3);
                            }
                            
                            if (textSrc && audioSrc) {
                                this.queue.push({
                                    textSrc: textSrc,
                                    audioSrc: audioSrc,
                                    clipBegin: clipBegin,
                                    clipEnd: clipEnd,
                                    originalIndex: fragmentsAdded
                                });
                                fragmentsAdded++;
                            }
                        }
                    }
                    
                    return fragmentsAdded;
                    
                } catch (error) {
                    this.updateInfo(`<span class="error">âŒ è§£æå¤±è´¥: ${error.message}</span>`);
                    return 0;
                }
            }

            // --- éŸ³é¢‘æ–‡ä»¶åˆ†ç»„ ---
            groupFragmentsByAudio() {
                const groups = new Map();
                
                this.queue.forEach((fragment, index) => {
                    const audioFile = fragment.audioSrc;
                    if (!groups.has(audioFile)) {
                        groups.set(audioFile, []);
                    }
                    groups.get(audioFile).push({
                        ...fragment,
                        originalIndex: index
                    });
                });
                
                return groups;
            }

            // --- éŸ³é¢‘URLè·å–æ–¹æ³• ---
            async getAudioUrl(audioPath) {
                const methods = [
                    // æ–¹æ³•1: createUrl (æ–°ç‰ˆæœ¬Epub.js)
                    async () => {
                        if (this.book.archive.createUrl) {
                            return this.book.archive.createUrl(audioPath);
                        }
                        throw new Error('createUrl not available');
                    },
                    // æ–¹æ³•2: url (async) - éœ€è¦ç»å¯¹è·¯å¾„
                    async () => {
                        if (this.book.archive.url) {
                            const absolutePath = `/${audioPath}`;
                            return await this.book.archive.url(absolutePath);
                        }
                        throw new Error('url not available');
                    },
                    // æ–¹æ³•3: getBlob + Object URL
                    async () => {
                        const absolutePath = `/${audioPath}`;
                        const blob = await this.book.archive.getBlob(absolutePath);
                        return URL.createObjectURL(blob);
                    }
                ];
                
                for (const method of methods) {
                    try {
                        const url = await method();
                        if (url) {
                            return url;
                        }
                    } catch (error) {
                        // ç»§ç»­å°è¯•ä¸‹ä¸€ä¸ªæ–¹æ³•
                    }
                }
                
                throw new Error('æ‰€æœ‰éŸ³é¢‘URLè·å–æ–¹æ³•éƒ½å¤±è´¥äº†');
            }

            // --- å®æ—¶é«˜äº®ç³»ç»Ÿ ---
            updateCurrentHighlight() {
                if (!this.isPlaying || !this.currentAudioFile) return;
                
                const currentTime = this.audioElement.currentTime;
                
                // æ›´æ–°è¿›åº¦æ¡
                this.updateProgressBar();
                
                // æŸ¥æ‰¾å½“å‰æ—¶é—´å¯¹åº”çš„ç‰‡æ®µ
                const currentFragment = this.findFragmentByTime(currentTime);
                
                if (currentFragment && currentFragment.index !== this.currentIndex) {
                    // å–æ¶ˆä¹‹å‰çš„é«˜äº®
                    if (this.currentIndex >= 0) {
                        this.highlightCurrentFragment(false, this.currentIndex);
                    }
                    
                    // è®¾ç½®æ–°çš„é«˜äº®
                    this.currentIndex = currentFragment.index;
                    this.highlightCurrentFragment(true, this.currentIndex);
                    this.updateFragmentId(currentFragment.fragmentId);
                    
                    console.log(`é«˜äº®ç‰‡æ®µ ${this.currentIndex}: ${currentFragment.fragmentId} (æ—¶é—´: ${currentTime.toFixed(2)}s)`);
                }
            }

            // æ ¹æ®æ—¶é—´æŸ¥æ‰¾å¯¹åº”çš„ç‰‡æ®µ
            findFragmentByTime(currentTime) {
                const fragments = this.audioGroups.get(this.currentAudioFile) || [];
                
                for (let i = 0; i < fragments.length; i++) {
                    const fragment = fragments[i];
                    const startTime = this.timeToSeconds(fragment.clipBegin);
                    const endTime = this.timeToSeconds(fragment.clipEnd);
                    
                    if (currentTime >= startTime && currentTime <= endTime) {
                        const [, fragmentId] = fragment.textSrc.split('#');
                        return {
                            index: fragment.originalIndex,
                            fragmentId: fragmentId,
                            startTime: startTime,
                            endTime: endTime
                        };
                    }
                }
                return null;
            }

            // æ›´æ–°è¿›åº¦æ¡
            updateProgressBar() {
                if (this.audioElement.duration) {
                    const progress = (this.audioElement.currentTime / this.audioElement.duration) * 100;
                    document.getElementById('progress-bar').style.width = progress + '%';
                    
                    // æ›´æ–°æ—¶é—´æ˜¾ç¤º
                    const currentTime = this.formatTime(this.audioElement.currentTime);
                    const totalTime = this.formatTime(this.audioElement.duration);
                    document.getElementById('time-display').textContent = `${currentTime} / ${totalTime}`;
                }
            }

            // æ ¼å¼åŒ–æ—¶é—´æ˜¾ç¤º
            formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }

            // --- æ’­æ”¾æ§åˆ¶é€»è¾‘ ---

            async play() {
                if (this.queue.length === 0) return;

                this.isPlaying = true;
                this.updateStatus("â–¶ï¸ æ­£åœ¨æ’­æ”¾...");
                await this.playByAudioFiles();
            }

            pause() {
                this.isPlaying = false;
                this.audioElement.pause();
                this.updateStatus("â¸ï¸ å·²æš‚åœ");
            }

            stop() {
                this.isPlaying = false;
                this.audioElement.pause();
                this.audioElement.currentTime = 0;
                this.highlightCurrentFragment(false);
                this.currentIndex = -1;
                this.currentAudioFile = null;
                this.updateStatus("â¹ï¸ å·²åœæ­¢");
                this.updateFragmentId("N/A");
                document.getElementById('progress-bar').style.width = '0%';
                document.getElementById('time-display').textContent = '00:00 / 00:00';
            }

            // æŒ‰éŸ³é¢‘æ–‡ä»¶åˆ†ç»„æ’­æ”¾
            async playByAudioFiles() {
                if (this.audioGroups.size === 0) return;
                
                for (const [audioFile, fragments] of this.audioGroups) {
                    if (!this.isPlaying) break; // å¦‚æœç”¨æˆ·åœæ­¢äº†æ’­æ”¾
                    
                    this.currentAudioFile = audioFile;
                    this.updateInfo(`<strong>å¼€å§‹æ’­æ”¾éŸ³é¢‘: ${audioFile}</strong>`);
                    
                    // æ˜¾ç¤ºç¬¬ä¸€ä¸ªç‰‡æ®µçš„é¡µé¢ï¼ˆå¦‚æœéœ€è¦åˆ‡æ¢é¡µé¢ï¼‰
                    if (fragments.length > 0) {
                        const firstFragment = fragments[0];
                        let textSrc = firstFragment.textSrc;
                        if (textSrc.startsWith('../')) {
                            textSrc = textSrc.substring(3);
                        }
                        const [htmlFile] = textSrc.split('#');
                        
                        await this.rendition.display(htmlFile);
                        await new Promise(resolve => setTimeout(resolve, 300));
                    }
                    
                    // æ’­æ”¾æ•´ä¸ªéŸ³é¢‘æ–‡ä»¶
                    await this.playAudioFile(audioFile, fragments);
                }
                
                if (this.isPlaying) {
                    this.isPlaying = false;
                    this.updateStatus("âœ… æ‰€æœ‰éŸ³é¢‘æ’­æ”¾å®Œæˆ");
                }
            }

            // æ’­æ”¾å•ä¸ªéŸ³é¢‘æ–‡ä»¶
            async playAudioFile(audioFile, fragments) {
                try {
                    const audioUrl = await this.getAudioUrl(audioFile);
                    this.audioElement.src = audioUrl;
                    this.audioElement.currentTime = 0;
                    
                    // é‡ç½®é«˜äº®
                    if (this.currentIndex >= 0) {
                        this.highlightCurrentFragment(false, this.currentIndex);
                    }
                    this.currentIndex = -1;
                    this.updateFragmentId("å‡†å¤‡æ’­æ”¾...");
                    
                    // å¼€å§‹æ’­æ”¾
                    await this.audioElement.play();
                    this.updateStatus(`â–¶ï¸ æ­£åœ¨æ’­æ”¾: ${audioFile}`);
                    
                    // ç­‰å¾…æ’­æ”¾å®Œæˆæˆ–è¢«ä¸­æ–­
                    await new Promise((resolve) => {
                        const checkEnd = () => {
                            if (!this.isPlaying || this.audioElement.ended || this.audioElement.currentTime >= this.audioElement.duration - 0.5) {
                                resolve();
                            } else {
                                setTimeout(checkEnd, 100);
                            }
                        };
                        checkEnd();
                    });
                    
                } catch (error) {
                    console.error(`æ’­æ”¾éŸ³é¢‘å¤±è´¥: ${audioFile}`, error);
                    this.updateStatus(`âŒ æ’­æ”¾å¤±è´¥: ${audioFile}`, 'error');
                }
            }

            // å¿«è¿›å¿«é€€åŠŸèƒ½
            seekForward() {
                if (this.audioElement.duration) {
                    this.audioElement.currentTime = Math.min(
                        this.audioElement.currentTime + 10,
                        this.audioElement.duration
                    );
                }
            }

            seekBackward() {
                if (this.audioElement.duration) {
                    this.audioElement.currentTime = Math.max(
                        this.audioElement.currentTime - 10,
                        0
                    );
                }
            }

            // --- UI/DOM åŒæ­¥ ---
            highlightCurrentFragment(highlight, index = this.currentIndex) {
                const fragment = this.queue[index];
                if (!fragment) {
                    return false;
                }
                
                const [, fragmentId] = fragment.textSrc.split('#');
                if (!fragmentId) {
                    return false;
                }

                try {
                    // è·å–æ–‡æ¡£
                    let targetDoc = null;
                    
                    if (this.rendition && this.rendition.getContents) {
                        const contents = this.rendition.getContents();
                        if (contents && contents.length > 0) {
                            targetDoc = contents[0].document;
                        }
                    }
                    
                    if (!targetDoc && this.rendition.manager && this.rendition.manager.container) {
                        const iframe = this.rendition.manager.container.querySelector('iframe');
                        if (iframe && iframe.contentDocument) {
                            targetDoc = iframe.contentDocument;
                        }
                    }
                    
                    if (!targetDoc) {
                        return false;
                    }
                    
                    const targetEl = targetDoc.getElementById(fragmentId);
                    
                    if (targetEl) {
                        targetEl.classList.toggle(this.activeClass, highlight);
                        
                        if (highlight) {
                            setTimeout(() => {
                                try {
                                    targetEl.scrollIntoView({ 
                                        behavior: 'smooth', 
                                        block: 'center'
                                    });
                                } catch (scrollError) {
                                    console.warn('æ»šåŠ¨å¤±è´¥:', scrollError);
                                }
                            }, 100);
                        }
                        return true;
                    }
                    
                    return false;
                    
                } catch (e) {
                    console.error('é«˜äº®é”™è¯¯:', e);
                    return false;
                }
            }

            // --- çŠ¶æ€æ›´æ–° ---

            updateStatus(message, type = 'success') {
                const statusEl = document.getElementById('player-status');
                statusEl.innerHTML = `<span class="${type}">${message}</span>`;
            }

            updateFragmentId(id) {
                document.getElementById('current-fragment-id').textContent = id;
            }

            updateInfo(message) {
                 this.infoOutput.innerHTML += `<p style="margin: 2px 0; font-size: 12px;">${message}</p>`;
            }
        }
        
        // --- å¯åŠ¨é€»è¾‘ ---
        async function init() {
            try {
                if (typeof JSZip === 'undefined') {
                    document.getElementById('info-output').innerHTML = '<p class="error">âŒ JSZip åº“æœªæ‰¾åˆ°ã€‚è¯·æ£€æŸ¥ CDN é“¾æ¥ã€‚</p>';
                    return;
                }
                
                book = ePub(EPUB_PATH);
                rendition = book.renderTo("viewer", { 
                    width: "100%", 
                    height: "100%",
                    flow: "scrolled-doc"
                });
                
                document.getElementById('info-output').innerHTML = '<p class="success">Epub.js å’Œ JSZip åˆå§‹åŒ–æˆåŠŸï¼Œæ­£åœ¨ç­‰å¾…å†…å®¹åŠ è½½...</p>';
                
                await rendition.displayed;
                
                player = new MediaOverlayPlayer(book, rendition, document.getElementById('info-output'));
                await player.initialize();
                
                // ç»‘å®š UI äº‹ä»¶
                document.getElementById('play-pause-btn').onclick = () => {
                    if (player.isPlaying) {
                        player.pause();
                    } else {
                        player.play();
                    }
                };
                document.getElementById('stop-btn').onclick = () => player.stop();
                document.getElementById('seek-back-btn').onclick = () => player.seekBackward();
                document.getElementById('seek-forward-btn').onclick = () => player.seekForward();
                
            } catch (e) {
                document.getElementById('info-output').innerHTML = `<p class="error">âŒ è‡´å‘½é”™è¯¯: ${e.message}</p>`;
                console.error("è‡´å‘½åˆå§‹åŒ–é”™è¯¯:", e);
            }
        }

        init();
    </script>
</body>
</html>